01背包组合问题
见494.目标和

一共有三种
第一种，装满大小为bagsize的背包，最大价值是多少（最基础）
首先从最最基本的**二维数组**引入

表格：
||重量|价值|
|---|---|---|
物品1|1|15|
物品2|3|20|
物品3|4|30|

暴力解法：回溯，每个物品选或者不选
时间复杂度$O(2^n)$

二维dp数组解法

当i放进去时，那么这时候整个物品集就被分成两部分，1到i-1和第i个，而这是i是确定要放进去的，那么就把j空间里的wi给占据了，只剩下j－wi的空间给前面i－1，那么只要这时候前面i－1在j－wi空间里构造出最大价值，即dp【i－1】【j－wi】，再加上此时放入的i的价值vi，就是dpij了

遍历顺序：这里先遍历物品再遍历背包或者先遍历背包再遍历物品都可以。本质上是根据递推公式来看，只要能保证左上方和正上方有数值就行（具体的递推公式具体分析，有时候遍历顺序有要求）


然后可以进行**一维数组（滚动数组）**优化
当前层是由上一层计算出来的，当前层算完之后上一层就没有用处了，所以我们考虑用当前层直接覆盖上一层，这样的思路就可以把二维数组压缩成一维数组

**核心理解：拷贝**

**倒序遍历**，否则正序的话，前面的数据被处理过，相当于是脏数据

具体原因是，二维dp，我们使用上一行的数据是独立于当前行的数据的，但是一维的时候，当前层的值是需要依赖上一层，但是上一层的数据被存在了当前层。如果是从左到右，先改了左边的值，就相当于改了上一层的值，但是你当前层后面数据还要依赖这些“上一层”的数据，这就是产生了脏数据。而从右往左的话，你利用的是干净的数据，不会对“上一层”数据进行改变（记住要依赖的数据都在左边，所以左边得最后动）

为什么要倒序感觉很多人还是没有说到点，首先这个一维dp就是相对于二维来说，对上一层进行一个复用，为什么要从右向左，因为如果是从左向右，我们的左边的值就不断更新为新的物品这一层的新状态新值，而我们计算的时候需要上一层状态，即遍历到上一个物品的那一层的状态，如果是从右向左，因为上一层遍历刚结束，左边的值还没改呢，所以此时，上一层就是原来的值，不需要改动，所以我们就从右向左，这样子左边的值都没改过



可以举一个具体例子 !todo


为什么要先遍历物品再遍历背包呢（还不是很能解释）
代码随想录里面的解释是：
首先背包容量一定是倒序的，如果先遍历背包容量再遍历物品，会相当于每个dp[j]里都只放了一个物品！



第二种，



第三种，01背包解决排列组合问题
